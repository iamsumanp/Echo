---
phase: 01-core-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/Echo/Views/ContentView.swift
autonomous: true
requirements:
  - PERF-01
  - SRCH-01

must_haves:
  truths:
    - "User can hold the arrow key and scroll through 100+ items without animation stutter or input delay"
    - "Searching for a word that appears in clipboard content (but not on the visible first line) returns the matching item"
  artifacts:
    - path: "Sources/Echo/Views/ContentView.swift"
      provides: "moveSelection without animation wrapping, filteredItems with full-content search"
      contains: "moveSelection"
  key_links:
    - from: "Sources/Echo/Views/ContentView.swift"
      to: "filteredItems"
      via: "filter closure using item.textContent"
      pattern: "textContent.*localizedCaseInsensitiveContains"
    - from: "Sources/Echo/Views/ContentView.swift"
      to: "moveSelection"
      via: "onKeyPress handlers calling moveSelection"
      pattern: "moveSelection\\(direction:"
---

<objective>
Fix two bugs in ContentView.swift: (1) arrow key navigation causes stutter due to animation wrapping on every keystroke, and (2) search filter already operates on full textContent but needs explicit verification and defensive coverage of all searchable fields.

Purpose: Make navigation feel instant and ensure search reliably finds content anywhere in a clipboard item's text.
Output: ContentView.swift with a non-animated moveSelection function and a clearly full-content search filter.
</objective>

<execution_context>
@/Users/boski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/boski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Sources/Echo/Views/ContentView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove animation from moveSelection and scrollTo</name>
  <files>Sources/Echo/Views/ContentView.swift</files>
  <action>
    In the `moveSelection(direction:)` function (around line 354), remove the `withAnimation(.easeInOut(duration: 0.12))` wrapper entirely. Set `selectedItemId` directly without animation:

    Change:
    ```swift
    if newIndex >= 0 && newIndex < filteredItems.count {
        withAnimation(.easeInOut(duration: 0.12)) {
            selectedItemId = filteredItems[newIndex].id
        }
    }
    ```
    To:
    ```swift
    if newIndex >= 0 && newIndex < filteredItems.count {
        selectedItemId = filteredItems[newIndex].id
    }
    ```

    In `listView` (around line 251), the `onChange(of: selectedItemId)` block calls `proxy.scrollTo(id, anchor: .center)` wrapped in `withAnimation(.easeInOut(duration: 0.15))`. Remove the `withAnimation` wrapper so scrolling is immediate:

    Change:
    ```swift
    .onChange(of: selectedItemId) {
        if let id = selectedItemId {
            withAnimation(.easeInOut(duration: 0.15)) {
                proxy.scrollTo(id, anchor: .center)
            }
        }
    }
    ```
    To:
    ```swift
    .onChange(of: selectedItemId) {
        if let id = selectedItemId {
            proxy.scrollTo(id, anchor: .center)
        }
    }
    ```

    Rationale: When the user holds down an arrow key, macOS fires many rapid key-repeat events. Each call to `moveSelection` was creating a new 0.12s animation for `selectedItemId`, and each `scrollTo` was creating another 0.15s animation. These queued up and caused visible stutter. Removing the animations makes selection update and scroll happen synchronously on the main thread each frame, which SwiftUI handles efficiently with its diffing.

    Do NOT remove the animation on mouse tap (`onTapGesture` in `rowView`) — that one fires at human speed and the subtle animation is fine to keep.
  </action>
  <verify>
    Build the app with `swift build` (or open in Xcode) — it must compile without errors.
    Manually: Open the app, hold down arrow key with 50+ items. Selection should track instantly without any stagger or delayed scroll.
  </verify>
  <done>
    `moveSelection` sets `selectedItemId` without any animation wrapper.
    `scrollTo` in listView's `onChange` is called without animation wrapper.
    App compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify and harden full-content search filter</name>
  <files>Sources/Echo/Views/ContentView.swift</files>
  <action>
    Inspect the `filteredItems` computed property's filter closure (around line 18). It currently reads:

    ```swift
    items = historyManager.items.filter { item in
        item.textContent?.localizedCaseInsensitiveContains(searchText) == true
            || item.applicationName?.localizedCaseInsensitiveContains(searchText) == true
    }
    ```

    This already searches the full `textContent` field (the raw, complete clipboard string). However, it does NOT search the trimmed version of the text that the title uses — but since `textContent` contains all the raw content, any substring search on it finds content anywhere in the text.

    The bug: items whose content appears only after leading whitespace or newlines (e.g. a multi-line copy that starts with blank lines) have their `textContent` start with `\n`, so `localizedCaseInsensitiveContains` still finds interior content. This is correct.

    To make SRCH-01 explicitly resolved and future-proof, update the filter to also search against a trimmed version of the content AND ensure the intent is documented:

    Replace the filter closure with:
    ```swift
    items = historyManager.items.filter { item in
        // Search full clipboard content (not just visible title)
        let contentMatch = item.textContent?.localizedCaseInsensitiveContains(searchText) == true
        let appMatch = item.applicationName?.localizedCaseInsensitiveContains(searchText) == true
        return contentMatch || appMatch
    }
    ```

    This is a clean-up: extract into named booleans for clarity and add a comment making the full-content intent explicit. The logic is identical but now self-documenting that `textContent` is the full clipboard string, not a truncated preview.

    NOTE: Do NOT change `textContent` to a trimmed version — always search the raw full content so that content that begins with whitespace or special characters is still found.
  </action>
  <verify>
    Build must succeed.
    Manual test: Copy a multi-line string like "Line One\nLine Two\nLine Three". Search for "Line Three" in the app — the item must appear in results.
    Search for "Unknown App Name" (something only in applicationName) — matching items appear.
    Search for a word that only appears in the middle of a long pasted string — item appears in results.
  </verify>
  <done>
    `filteredItems` filter uses `item.textContent` (full content) with a documenting comment.
    Search finds items regardless of where in the content the query appears.
    App compiles.
  </done>
</task>

</tasks>

<verification>
After both tasks:
- Run `swift build` from project root — zero errors, zero warnings introduced by these changes.
- Open app, hold down arrow key for 2+ seconds with 20+ items — no stutter, selection tracks immediately.
- Search for text known to appear in the body (not first line) of a multi-line clipboard item — it appears in results.
</verification>

<success_criteria>
1. Arrow key rapid navigation is smooth — selection moves immediately without queued animations causing lag.
2. Searching for content that appears anywhere in clipboard text (not just first line/display title) returns matching items.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-fixes/01-01-SUMMARY.md`
</output>

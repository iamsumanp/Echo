---
phase: 01-core-fixes
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - Sources/Echo/Models/HistoryManager.swift
  - Sources/Echo/Views/ContentView.swift
autonomous: true
requirements:
  - CLIP-01

must_haves:
  truths:
    - "Pinning a second item places it after the first pinned item in the list, not before it"
    - "The order of already-pinned items does not change when a new item is pinned"
  artifacts:
    - path: "Sources/Echo/Models/HistoryManager.swift"
      provides: "togglePin sets pinnedDate when pinning"
      contains: "pinnedDate"
    - path: "Sources/Echo/Views/ContentView.swift"
      provides: "filteredItems sort uses pinnedDate ascending for pinned group"
      contains: "pinnedDate"
  key_links:
    - from: "Sources/Echo/Models/HistoryManager.swift"
      to: "ClipboardItem.pinnedDate"
      via: "togglePin sets pinnedDate = Date() when pinning, nil when unpinning"
      pattern: "pinnedDate.*Date\\(\\)"
    - from: "Sources/Echo/Views/ContentView.swift"
      to: "filteredItems sort"
      via: "pinned items sorted by pinnedDate ascending so oldest pin appears first"
      pattern: "pinnedDate"
---

<objective>
Fix pin ordering so that newly pinned items are appended to the end of the pinned group rather than prepended. Currently, pinning an item places it first in the pinned section because the sort uses dateCreated descending for all pinned items. The fix uses the existing pinnedDate field on ClipboardItem: set it when pinning, then sort pinned items by pinnedDate ascending.

Purpose: Pinning should preserve the user's intentional ordering — the first thing they pinned stays at top.
Output: HistoryManager.togglePin sets pinnedDate, ContentView.filteredItems sorts pinned items by pinnedDate ascending.
</objective>

<execution_context>
@/Users/boski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/boski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Sources/Echo/Models/HistoryManager.swift
@Sources/Echo/Views/ContentView.swift
@Sources/Echo/Models/ClipboardItem.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set pinnedDate in HistoryManager.togglePin</name>
  <files>Sources/Echo/Models/HistoryManager.swift</files>
  <action>
    `ClipboardItem` already has a `pinnedDate: Date?` field (defined in ClipboardItem.swift) but `togglePin` never sets it. Fix this.

    Current `togglePin` (around line 136):
    ```swift
    func togglePin(for id: UUID) {
        if let index = items.firstIndex(where: { $0.id == id }) {
            items[index].isPinned.toggle()
            saveHistory()
        }
    }
    ```

    Replace with:
    ```swift
    func togglePin(for id: UUID) {
        if let index = items.firstIndex(where: { $0.id == id }) {
            let nowPinned = !items[index].isPinned
            items[index].isPinned = nowPinned
            items[index].pinnedDate = nowPinned ? Date() : nil
            saveHistory()
        }
    }
    ```

    This sets `pinnedDate` to the current timestamp when an item is pinned, and clears it to `nil` when unpinned. Existing items that were pinned before this fix will have `pinnedDate == nil` — the sort in Plan 02 Task 2 handles this gracefully by treating nil pinnedDate as "pinned at epoch" (i.e., sorts before items with a real pinnedDate, keeping existing pin order stable).

    Note: `ClipboardItem` uses `var isPinned: Bool` and `var pinnedDate: Date?` — both are mutable `var` properties, so direct mutation via index subscript is valid.
  </action>
  <verify>
    `swift build` compiles without errors.
    After pinning an item, inspect the saved JSON at `~/Library/Application Support/Echo/clipboard_history.json` — the pinned item must have a non-null `pinnedDate` field.
  </verify>
  <done>
    `togglePin` sets `pinnedDate = Date()` when pinning and `pinnedDate = nil` when unpinning.
    JSON serialization includes `pinnedDate` for pinned items.
  </done>
</task>

<task type="auto">
  <name>Task 2: Sort pinned items by pinnedDate ascending in filteredItems</name>
  <files>Sources/Echo/Views/ContentView.swift</files>
  <action>
    In `ContentView.filteredItems` (around line 25), the sort currently reads:

    ```swift
    return items.sorted { (item1, item2) -> Bool in
        if item1.isPinned && !item2.isPinned {
            return true
        } else if !item1.isPinned && item2.isPinned {
            return false
        } else {
            return item1.dateCreated > item2.dateCreated
        }
    }
    ```

    The `else` branch (both pinned OR both unpinned) uses `dateCreated` descending. For pinned items this means the most-recently-copied item is shown first — but the requirement is that the FIRST item pinned stays at top (oldest pin first = ascending pinnedDate).

    Replace the sort with:
    ```swift
    return items.sorted { (item1, item2) -> Bool in
        if item1.isPinned && !item2.isPinned {
            return true
        } else if !item1.isPinned && item2.isPinned {
            return false
        } else if item1.isPinned && item2.isPinned {
            // Both pinned: sort by when they were pinned, oldest pin first (ascending)
            // nil pinnedDate means pinned before this fix — treat as earliest
            let date1 = item1.pinnedDate ?? .distantPast
            let date2 = item2.pinnedDate ?? .distantPast
            return date1 < date2
        } else {
            // Both unpinned: sort by creation date, newest first
            return item1.dateCreated > item2.dateCreated
        }
    }
    ```

    This achieves CLIP-01: pinning a new item gives it the most recent `pinnedDate`, so it sorts AFTER all existing pins (ascending order). Items pinned before this fix have `pinnedDate == nil` and are treated as `.distantPast`, so they sort before newer pins — this preserves their relative order by date (they'll end up sorted by `.distantPast` == same value, so their relative order is stable from the previous sort which was by `dateCreated`).

    Do NOT change the section rendering in `listView` — it already correctly separates pinned vs unpinned into Sections.
  </action>
  <verify>
    `swift build` compiles without errors.
    Manual test:
    1. Ensure you have 2+ unpinned items.
    2. Pin item B (it appears at top of pinned section).
    3. Pin item C (it must appear BELOW item B in the pinned section, not above).
    4. Unpin item B — item C remains in pinned section, item B moves to recent.
    5. Pin item B again — item B appears BELOW item C (it was pinned later).
  </verify>
  <done>
    In `filteredItems`, the sort for two pinned items compares `pinnedDate` ascending (nil treated as `.distantPast`).
    Newly pinned items appear at the bottom of the pinned group, not the top.
    Unpinned items continue to sort by `dateCreated` descending.
  </done>
</task>

</tasks>

<verification>
After both tasks:
- `swift build` — zero errors.
- Pin item A, then pin item B. In the Pinned section, item A must be above item B.
- Pin item C. Order must be: A, B, C (pinned in chronological order).
- Unpin B, then re-pin B. Order must be: A, C, B.
- Items with `pinnedDate == nil` (pre-existing pins from before this fix) sort before items with a real pinnedDate, preserving their order.
</verification>

<success_criteria>
1. Pinning an item places it at the END of the pinned group, after all currently pinned items.
2. Re-pinning an item treats it as newly pinned (appended to end of pinned group).
3. Unpinned items still sort by recency (newest first).
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-fixes/01-02-SUMMARY.md`
</output>
